# owner

> 堆上分配的资源总是拥有一个owner，不会大于一个

> 堆上分配的资源会在owner离开作用域后释放

> 个人理解：owner转移后，前一个变量立即无效，没有任何理由需要两个变量同时拥有一份资源，至少在cpu看来是这样的

> 所以rust在程序级做了强制要求

> 对于传值函数，ownership会被隐式转移到函数里，如果没有传出

> 那么资源在函数外部将无法继续访问

> 这就强迫coder在应该传引用的地方，必须显式引用

> 在c++如果大对象传值，直接复制一个copy，不会在编译或者运行时给任何提示

> rust语言中，传引用给函数，不夺取owner，这种情况下叫做borrowing，借用

`let mut s = String::from("a");
let r1 = &mut s;
let r2 = &mut s;`

> 上面的代码是不允许的，相同作用域中，同一份资源只允许有一个可变引用

> 这与rust的单一ownership的原则一致

> 在语法级别避免数据竞争，也算一种不错的尝试

> 加一句：不可变引用可以有多份

